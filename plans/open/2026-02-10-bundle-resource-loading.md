# Bundle Resource Loading Support

## Preface

This plan integrates Foundation.Bundle into TUIkit for resource loading (images, data files, localized strings). Rather than reimplementing Bundle, we leverage SPM's automatic Bundle.module generation for resource management. The implementation adds resource declarations to Package.swift, organizes assets in a Resources directory, and provides type-safe resource accessors. This enables Image(_:bundle:) API and future features like localized strings, custom fonts, and data-driven UI components. The approach is cross-platform (macOS + Linux), requires zero custom Bundle code, and follows Apple's SPM resource conventions.

## Context/Problem

TUIkit currently has no resource loading mechanism. This blocks:
- `Image(_:bundle:)` API (needs to load PNG/JPEG files)
- Localized strings (future: multi-language support)
- Data-driven UI (JSON configs, lookup tables)
- Custom fonts/glyphs (future: icon sets)

**Current State:**
- No Resources directory
- No resource declarations in Package.swift
- No `Bundle.module` available
- All data must be hardcoded in Swift

**Research Findings:**
- Foundation.Bundle already exists on macOS + Linux
- SPM auto-generates `Bundle.module` when resources declared in Package.swift
- No need to reimplement Bundle (unlike SwiftUI-specific protocols)
- Cross-platform: macOS uses .bundle structure, Linux uses flat structure, Foundation abstracts this

## Specification/Goal

Enable resource loading via Foundation.Bundle:

```swift
// SPM auto-generates this:
extension Bundle {
    static let module: Bundle { ... }  // Points to TUIkit_TUIkit.bundle
}

// Usage in TUIkit:
Image("logo", bundle: .module)

// Type-safe accessors (future):
TUIResource.Icon.checkmark.load()
TUIResource.Data.unicode.load()
```

**Supported Resource Types:**
- Images: PNG, JPEG (via Image view)
- Data files: JSON, TXT, binary
- Localized strings: .strings files (future)
- Custom assets: fonts, glyphs, themes (future)

**SPM Integration:**
```swift
// Package.swift
.target(
    name: "TUIkit",
    resources: [
        .process("Resources")  // Optimizes images, preserves structure
    ]
)
```

**Resource Organization:**
```
Sources/TUIkit/Resources/
  Icons/
    checkmark.png
    cross.png
  Data/
    unicode-blocks.json
```

**API Philosophy:**
- Use `Bundle.module` directly (no wrapper needed)
- URL-based APIs (cross-platform file handling)
- Type-safe accessors for internal resources
- Standard Bundle API for external bundles

## Design

### Architecture

```
┌───────────────────────────────────────┐
│ SPM Build System                      │
│ ┌───────────────────────────────────┐ │
│ │ Package.swift                     │ │
│ │  .target(resources: .process())   │ │
│ └───────────────────────────────────┘ │
│              ↓                        │
│ Auto-generates:                       │
│   extension Bundle {                  │
│     static let module: Bundle         │
│   }                                   │
└───────────────────────────────────────┘
              ↓
┌───────────────────────────────────────┐
│ TUIkit Resource Loading               │
│ ┌───────────────────────────────────┐ │
│ │ TUIResource (type-safe accessors) │ │
│ │  enum Icon: String                │ │
│ │  enum Data: String                │ │
│ └───────────────────────────────────┘ │
│              ↓                        │
│ ┌───────────────────────────────────┐ │
│ │ Bundle.module.url(forResource:)   │ │
│ └───────────────────────────────────┘ │
│              ↓                        │
│ ┌───────────────────────────────────┐ │
│ │ Foundation.Data / ImageLoader     │ │
│ └───────────────────────────────────┘ │
└───────────────────────────────────────┘
```

### Bundle.module (Auto-Generated by SPM)

**What SPM generates** (conceptually, actual code is opaque):
```swift
extension Bundle {
    static let module: Bundle = {
        let bundleName = "TUIkit_TUIkit"  // <Package>_<Target>
        
        // Search order:
        // 1. Bundle.main.bundleURL (app resources)
        // 2. Bundle(for: AnyTUIKitClass.self).resourceURL (framework)
        // 3. Executable directory (CLI tools)
        
        guard let url = findBundleURL(named: bundleName),
              let bundle = Bundle(url: url) else {
            fatalError("Cannot find resource bundle: \(bundleName)")
        }
        return bundle
    }()
}
```

**Key Points:**
- Generated automatically when target has `resources:` in Package.swift
- Name format: `<PackageName>_<TargetName>.bundle`
- Works on macOS (bundle structure) and Linux (flat structure)
- Foundation handles platform differences

### Resource Organization

**Directory Structure:**
```
Sources/
  TUIkit/
    Resources/                 # Root for all resources
      Icons/                   # Image assets
        checkmark.png
        cross.png
        chevron-up.png
        chevron-down.png
      Data/                    # JSON, TXT, etc.
        unicode-blocks.json    # Future: Unicode lookup tables
        box-drawing.json       # Future: Custom box chars
```

**Package.swift Declaration:**
```swift
.target(
    name: "TUIkit",
    dependencies: [...],
    resources: [
        .process("Resources")  // Optimizes images, preserves directory structure
    ]
)
```

**Resource Rules:**
- `.process()`: Optimizes images (PNG compression), compiles Asset Catalogs (Apple platforms)
- `.copy()`: Copies verbatim, preserves exact structure
- For images: Use `.process()` (optimization)
- For data files: Either works (process preferred)

### Type-Safe Resource Accessors

**Problem:** Raw strings are error-prone:
```swift
Bundle.module.url(forResource: "checkmrak", withExtension: "png")  // Typo!
```

**Solution:** Enums with compile-time safety:
```swift
public enum TUIResource {
    public enum Icon: String, CaseIterable {
        case checkmark
        case cross
        case chevronUp = "chevron-up"
        case chevronDown = "chevron-down"
        
        public func url(in bundle: Bundle = .module) -> URL? {
            bundle.url(
                forResource: rawValue,
                withExtension: "png",
                subdirectory: "Icons"
            )
        }
        
        public func load(from bundle: Bundle = .module) -> Image? {
            guard let url = url(in: bundle) else { return nil }
            return Image.load(from: url)
        }
    }
    
    public enum Data: String, CaseIterable {
        case unicodeBlocks = "unicode-blocks"
        case boxDrawing = "box-drawing"
        
        public func url(in bundle: Bundle = .module) -> URL? {
            bundle.url(
                forResource: rawValue,
                withExtension: "json",
                subdirectory: "Data"
            )
        }
        
        public func load<T: Decodable>(
            as type: T.Type,
            from bundle: Bundle = .module
        ) throws -> T {
            guard let url = url(in: bundle) else {
                throw ResourceError.notFound(rawValue)
            }
            let data = try Foundation.Data(contentsOf: url)
            return try JSONDecoder().decode(T.self, from: data)
        }
    }
}

enum ResourceError: Error {
    case notFound(String)
}
```

**Usage:**
```swift
// Type-safe, autocomplete, compile-time checks
let icon = TUIResource.Icon.checkmark.load()

// Data loading with decoding
struct UnicodeBlock: Codable { ... }
let blocks = try TUIResource.Data.unicodeBlocks.load(as: [UnicodeBlock].self)
```

### Cross-Platform Bundle Structure

**macOS (Bundle Format):**
```
TUIkit_TUIkit.bundle/
  Contents/
    Info.plist
    Resources/
      Icons/
        checkmark.png
      Data/
        unicode-blocks.json
```

**Linux (Flat Format):**
```
TUIkit_TUIkit.bundle/
  Icons/
    checkmark.png
  Data/
    unicode-blocks.json
```

**Foundation handles this!** Use URL-based APIs only:
```swift
// ✅ Cross-platform
let url = Bundle.module.url(forResource: "logo", withExtension: "png")

// ❌ Platform-specific (don't use)
let path = Bundle.module.bundlePath + "/Resources/Icons/logo.png"
```

### Image Integration

**Image view uses Bundle:**
```swift
public struct Image: View {
    let source: ImageSource
    
    public init(_ name: String, bundle: Bundle? = nil) {
        self.source = .named(name, bundle: bundle ?? .module)
    }
}

// Internal loading:
private func loadImageData(name: String, bundle: Bundle) -> Data? {
    // Try common extensions
    for ext in ["png", "jpg", "jpeg"] {
        if let url = bundle.url(forResource: name, withExtension: ext),
           let data = try? Data(contentsOf: url) {
            return data
        }
    }
    return nil
}
```

## Implementation Plan

### Phase 1: SPM Resource Declaration

**1.1 Create Resources directory structure**
```bash
mkdir -p Sources/TUIkit/Resources/Icons
mkdir -p Sources/TUIkit/Resources/Data
```

**1.2 Update Package.swift**
Add `resources:` to TUIkit target:
```swift
.target(
    name: "TUIkit",
    dependencies: [...],
    resources: [
        .process("Resources")
    ]
)
```

**1.3 Verify Bundle.module generation**
- Build project: `swift build`
- Check generated code (opaque, but verify no build errors)
- Verify bundle exists in build output

**Tests:**
- Build succeeds
- Bundle.module accessible in code
- Bundle.module.bundlePath points to correct location

### Phase 2: Type-Safe Accessors

**2.1 Create TUIResource enum**
- `Sources/TUIkit/Resources/TUIResource.swift`
- Nested enums: `Icon`, `Data`
- `url(in:)` and `load()` methods

**2.2 Add ResourceError**
```swift
public enum ResourceError: Error, CustomStringConvertible {
    case notFound(String)
    case invalidData(String)
    case decodingFailed(String, Error)
    
    public var description: String {
        switch self {
        case .notFound(let name):
            return "Resource not found: \(name)"
        case .invalidData(let name):
            return "Invalid data in resource: \(name)"
        case .decodingFailed(let name, let error):
            return "Failed to decode \(name): \(error)"
        }
    }
}
```

**Tests:**
- Enum cases match actual resource files
- url(in:) returns correct URLs
- load() returns non-nil for valid resources
- Error handling for missing resources

### Phase 3: Add Sample Resources

**3.1 Add placeholder icons**
Create simple PNG icons (10x10, single-color):
- `checkmark.png` (green checkmark)
- `cross.png` (red X)
- `chevron-up.png` (up arrow)
- `chevron-down.png` (down arrow)

**3.2 Add sample data file**
Create `unicode-blocks.json`:
```json
{
  "blocks": [
    {"name": "Basic Latin", "start": 0, "end": 127},
    {"name": "Latin-1 Supplement", "start": 128, "end": 255}
  ]
}
```

**3.3 Update TUIResource enums**
Add cases for new resources.

**Tests:**
- All resources loadable via TUIResource
- Icon URLs point to existing files
- Data JSON parses correctly

### Phase 4: Integration with Image

**4.1 Update Image initializer**
Modify `Image(_:bundle:)` to use Bundle:
```swift
public init(_ name: String, bundle: Bundle? = nil) {
    self.source = .named(name, bundle: bundle ?? .module)
}
```

**4.2 Update ImageLoader protocol**
Add bundle-aware loading:
```swift
protocol ImageLoader {
    func loadImage(named: String, in bundle: Bundle) throws -> RGBAImage
    func loadImage(from url: URL) throws -> RGBAImage
}
```

**4.3 Implement bundle-aware loading**
```swift
func loadImage(named name: String, in bundle: Bundle) throws -> RGBAImage {
    // Try common extensions
    for ext in ["png", "jpg", "jpeg"] {
        if let url = bundle.url(forResource: name, withExtension: ext) {
            return try loadImage(from: url)
        }
    }
    throw ResourceError.notFound(name)
}
```

**Tests:**
- Image(_:bundle: .module) loads from TUIkit resources
- Image(_:bundle: .main) works for app resources
- Image(_:bundle: customBundle) works for external bundles
- Missing resources throw appropriate errors

### Phase 5: Documentation & Examples

**5.1 Add doc comments**
Document all public APIs:
- `TUIResource` and nested enums
- `ResourceError`
- Bundle parameter in `Image(_:bundle:)`

**5.2 Create usage examples**
Add to TUIkitExample:
```swift
VStack {
    // Using type-safe accessors
    if let icon = TUIResource.Icon.checkmark.load() {
        icon
            .resizable()
            .frame(width: 20, height: 10)
    }
    
    // Using custom bundle
    Image("logo", bundle: .main)
        .resizable()
        .frame(width: 40, height: 20)
}
```

**5.3 Update documentation**
- Add "Resource Loading" section to docs
- Explain SPM resource conventions
- Show type-safe accessor pattern
- Document cross-platform considerations

**Tests:**
- Example code compiles and runs
- Documentation examples are accurate

### Phase 6: Test Infrastructure

**6.1 Add test resources**
Update Package.swift:
```swift
.testTarget(
    name: "TUIkitTests",
    dependencies: ["TUIkit"],
    resources: [
        .copy("Resources")  // Test fixtures
    ]
)
```

**6.2 Create test fixtures**
```
Tests/TUIkitTests/Resources/
  Images/
    test-pattern.png
    corrupt.png
  Data/
    valid.json
    invalid.json
```

**6.3 Write resource loading tests**
- Load test images from Bundle.module (in tests)
- Handle corrupt files gracefully
- Test missing resources
- Verify cross-platform paths work

## Checklist

### Phase 1: SPM Setup
- [ ] Create Sources/TUIkit/Resources directory structure
- [ ] Create Resources/Icons subdirectory
- [ ] Create Resources/Data subdirectory
- [ ] Add resources declaration to Package.swift
- [ ] Verify swift build succeeds
- [ ] Verify Bundle.module accessible

### Phase 2: Type-Safe Accessors
- [ ] Create Sources/TUIkit/Resources/TUIResource.swift
- [ ] Implement TUIResource.Icon enum with url() and load()
- [ ] Implement TUIResource.Data enum with url() and load()
- [ ] Create ResourceError enum
- [ ] Write tests for accessor methods

### Phase 3: Sample Resources
- [ ] Create placeholder PNG icons (checkmark, cross, chevrons)
- [ ] Create sample JSON data file
- [ ] Update TUIResource enums with new cases
- [ ] Test all resources load correctly

### Phase 4: Image Integration
- [ ] Update Image(_:bundle:) initializer
- [ ] Add bundle parameter support to ImageLoader protocol
- [ ] Implement bundle-aware image loading
- [ ] Test Image with .module, .main, custom bundles
- [ ] Test error handling for missing resources

### Phase 5: Documentation
- [ ] Add doc comments to TUIResource
- [ ] Add doc comments to ResourceError
- [ ] Document Image bundle parameter
- [ ] Create usage examples in TUIkitExample
- [ ] Update project documentation

### Phase 6: Test Infrastructure
- [ ] Add test resources to TUIkitTests target
- [ ] Create test fixture files (images, data)
- [ ] Write resource loading tests
- [ ] Test error cases (missing, corrupt files)
- [ ] Verify cross-platform compatibility

## Open Questions

1. **Resource naming convention**: kebab-case (chevron-up) or camelCase (chevronUp) for files?
   - Recommendation: kebab-case (matches web conventions, better readability)

2. **Icon format**: PNG only or support SVG (future)?
   - Recommendation: PNG for now, SVG requires rasterization (future feature)

3. **Data file formats**: JSON only or YAML, PLIST, etc.?
   - Recommendation: JSON (cross-platform, no dependencies)

4. **Localization strategy**: .strings files (Apple) or custom JSON?
   - Recommendation: Defer to future plan, use .strings for Apple compatibility

5. **Resource versioning**: How to handle breaking changes in resource files?
   - Recommendation: Treat as breaking API changes, use semver

## Dependencies

**External:**
- Foundation (built-in): Bundle, Data, URL, FileManager, JSONDecoder

**Internal:**
- ImageLoader: Will use TUIResource.Icon.url() to get image paths
- Image view: Uses Bundle parameter for resource lookup

**SPM:**
- Swift Package Manager: Auto-generates Bundle.module

## Files

**New:**
- `Sources/TUIkit/Resources/` (directory)
- `Sources/TUIkit/Resources/Icons/` (directory)
- `Sources/TUIkit/Resources/Data/` (directory)
- `Sources/TUIkit/Resources/TUIResource.swift`
- `Sources/TUIkit/Resources/ResourceError.swift`
- `Tests/TUIkitTests/Resources/` (test fixtures)
- `Tests/TUIkitTests/Resources/ResourceLoadingTests.swift`

**Modified:**
- `Package.swift` (add resources to TUIkit target and TUIkitTests target)
- `Sources/TUIkit/Views/Image.swift` (add bundle parameter support)
- `Sources/TUIkit/Image/ImageLoader.swift` (add bundle-aware loading)

**Resources Added:**
- `checkmark.png`
- `cross.png`
- `chevron-up.png`
- `chevron-down.png`
- `unicode-blocks.json`
